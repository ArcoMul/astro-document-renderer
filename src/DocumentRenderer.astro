---
type Text = {
  text: string;
  [key: string]: unknown;
};

type Element = {
  children: Node[];
  [key: string]: unknown;
};

type Node = Element | Text;

interface Props {
  document: Node[];
  renderers?: {
    inline?: Partial<Renderers["inline"]>;
    block?: Partial<Renderers["block"]>;
  };
  componentBlocks?: any;
}

type Component<Props> = (props: Props) => any;

type Mark =
  | "bold"
  | "italic"
  | "underline"
  | "strikethrough"
  | "code"
  | "superscript"
  | "subscript"
  | "keyboard";

type OnlyChildrenComponent = Component<{ children: Node }> | string;

type MarkRenderers = { [Key in Mark]: OnlyChildrenComponent };

interface Renderers {
  inline: {
    link: Component<{ children: Node; href: string }> | "a";
    relationship:
      | Component<{
          relationship: string;
          data: {
            id: string;
            label: string | undefined;
            data: Record<string, any> | undefined;
          } | null;
        }>
      | "span";
  } & MarkRenderers;
  block: {
    block: OnlyChildrenComponent;
    paragraph: Component<{
      children: Node;
      textAlign: "center" | "end" | undefined;
    }>;
    blockquote: OnlyChildrenComponent;
    code: Component<{ children: string }>;
    layout: Component<{
      layout: [number, ...number[]];
      children: Element[];
      documentRendererProps: Pick<Props, "renderers" | "componentBlocks">;
    }>;
    divider: Component<{}>;
    heading: Component<{
      level: 1 | 2 | 3 | 4 | 5 | 6;
      children: Node;
      textAlign: "center" | "end" | undefined;
    }>;
    list: Component<{ type: "ordered" | "unordered"; children: Element[] }>;
  };
}

const defaultRenderers = {
  inline: {
    bold: "strong",
    code: "code",
    keyboard: "kbd",
    strikethrough: "s",
    italic: "em",
    link: "a",
    subscript: "sub",
    superscript: "sup",
    underline: "u",
    relationship: "span",
    // relationship: ({ data }) => {
    //   return <span>{data?.label || data?.id}</span>;
    // },
  },
  block: {},
};

const {
  document,
  renderers: _renderers = { inline: {}, block: {} },
  componentBlocks,
} = Astro.props;

const renderers = {
  inline: { ...defaultRenderers.inline, ..._renderers.inline },
  block: { ...defaultRenderers.block, ..._renderers.block },
} as {
  inline: Partial<Renderers["inline"]>;
  block: Partial<Renderers["block"]>;
};
---

{
  document.map((node) => {
    if (node.text) {
      let child = node.text;
      let marks: OnlyChildrenComponent[] = [];
      (Object.keys(renderers.inline) as (keyof Renderers["inline"])[]).forEach(
        (markName) => {
          if (
            markName !== "link" &&
            markName !== "relationship" &&
            node[markName] &&
            renderers.inline[markName]
          ) {
            marks.push(renderers.inline[markName]);
            // const Mark = renderers.inline[markName];
            // child = <Mark>{child}</Mark>;
          }
        }
      );
      return (
        <>
          {marks.length > 0
            ? marks.reduce((child, Mark) => <Mark>{child}</Mark>, child)
            : child}
        </>
      );
    } else if (node.type) {
      switch (node.type as string) {
        case "heading": {
          const Heading = `h${node.level}`;
          return (
            <Heading>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </Heading>
          );
        }
        case "paragraph": {
          return (
            <p>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </p>
          );
        }
        case "ordered-list": {
          return (
            <ol>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </ol>
          );
        }
        case "unordered-list": {
          return (
            <ul>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </ul>
          );
        }
        case "list-item": {
          return (
            <li>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </li>
          );
        }
        case "paragraph": {
          return (
            <p>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </p>
          );
        }
        case "code": {
          // prettier-ignore
          return (
            <pre><Astro.self document={node.children as Node[]} renderers={renderers} /></pre>
          );
        }
        case "link": {
          return (
            <a href={node.href as string}>
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            </a>
          );
        }
        case "layout": {
          if (renderers.block.layout) {
            const Component = renderers.block.layout;
            return (
              <Component
                layout={node.layout as [number, ...number[]]}
                children={node.children as Element[]}
                documentRendererProps={{ componentBlocks, renderers }}
              />
            );
          }
          return (
            <div
              style={{
                display: "grid",
                gridTemplateColumns: ((node.layout as []) || [1])
                  .map((x) => `${x}fr`)
                  .join(" "),
              }}
            >
              {(node.children as Element[]).map((child) => (
                <div>
                  <Astro.self
                    document={child.children}
                    renderers={renderers}
                    componentBlocks={componentBlocks}
                  />
                </div>
              ))}
            </div>
          );
        }
        case "component-block": {
          const Component = componentBlocks[node.component as string];
          if (Component) {
            return (
              <Component
                {...node.props}
                getDocument={(key: string) => {
                  if (!node.children) return null;
                  const child = node.children.find(
                    (child) => child.propPath[0] === key
                  );
                  if (child) {
                    return child.children;
                  }
                  return null;
                }}
              />
            );
          }
        }
        default: {
          if (node.children) {
            return (
              <Astro.self
                document={node.children as Node[]}
                renderers={renderers}
              />
            );
          }
        }
      }
    } else {
      // return <p>Error {JSON.stringify(node, null, 2)}</p>;
    }
  })
}
